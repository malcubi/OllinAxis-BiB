!$Header: /usr/local/ollincvs/Codes/OllinAxis-BiB/src/base/arrays.config,v 1.74 2022/01/11 02:15:25 malcubi Exp $

! **************************************
! ***   FILE FOR ARRAY DECLARATION   ***
! **************************************

!               VERY IMPORTANT  (PLEASE READ)
!
! * Comments must be preceded by exclamation marks (like in Fortran).
!
! * Declare only one array per line.
!
! * Control statements for each array are indicated in a comment,
!   and MUST include the following keywords:
!
!   SYMMETRYR, SYMMETRYZ, INTENT, STORAGE
!
!   Notice that they must always come in this order, and they
!   must be separated by commas.
!
! * The keywords SYMMETRY* can have one of the following values:
!
!   SYMMETRY* = +1       The variable is even.
!                        (no space is allowed between + and 1)
!
!   SYMMETRY* = -1       The variable is odd.
!                        (no space is allowed between - and 1)
!
!   SYMMETRY* =  0       The variable will NOT be touched when
!                        updating the symmetries.
!
! * The keyword INTENT can have one of the following values:
!
!   INTENT = EVOLVE      The array is a main dynamical variable
!                        and will be updated during the evolution
!                        loop.  For each array of this type named
!                        "var", three extra arrays will be created:
!
!                        var_p = previous time level
!                        svar  = source term for evolution
!                        var_a = auxiliary array
!
!   INTENT = AUXILIARY   The array is not one of the main evolved variables,
!                        but can contain other important variables (derivatives,
!                        curvature components, etcetera).
!
!   INTENT = OUTPUT      The array will be calculated for output,
!                        so memory will only be allocated if we want
!                        output for this array.
!
!   INTENT = POINTER     This array is actually a pointer.  They are
!                        declared with STORAGE always, but they are
!                        not actually allocated.
!
!   INTENT = ELLIPTIC    Similar to EVOLVE, but intended for "internal"
!                        iterations in an elliptic solver.
!
! * The keyword STORAGE can have one of the following values:
!
!   STORAGE = ALWAYS            Storage for this variable is always on.
!                               If the variable is of type OUTPUT this
!                               means it will be on when we need output.
!
!   STORAGE = CONDITIONAL(*)    In this case storage will be conditional
!                               on the condition inside the parenthesis.
!                               Notice that the condition must be a correctly
!                               formatted Fortran logical statement involving
!                               one of the parameters of the code (see e.g. shift).
!
! * The keyword ONELEVEL, when present, indicates that the array has only one
!   grid level.  This is useful for example for the synchronization pointer.
!
! * The keyword NOBOUND, when present, indicates that an evolving array has no
!   need for a boundary condition since its source can be calculated all the way
!   to the boundary.
!
! * The keyword NOSYNC, when present, indicates that the array should not be
!   sunchronized either across processors or across grids when they intersect.
!
! * The keyword ZEROD, when present, indicates that the "array" is not really an
!   array but rather just a global real variable. This is useful, for example,
!   when integrating the background in a cosmological spacetime.
!
! * The keyword CHECKPOINT, when present, indicates that this array should be saved
!   at checkpoint time even if it does not evolve.


! ********************
! ***   POINTERS   ***
! ********************

! Pointers used for synchronization, derivatives, interpolation, etc.

  REAL syncvar           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL diffvar           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL interpvar         ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS

! Pointer used when subroutine 'grabarray.f90' is called.  This routines takes
! the name of an array as a string and points 'grabarray' to it.  I declare it
! as an "elliptic" array in order to have all fine grid boundary information.

  REAL grabvar           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = ELLIPTIC, STORAGE = ALWAYS

! Pointers used for dissipation, radiative boundaries, etc.

  REAL evolvevar         ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL sourcevar         ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL Dr_var            ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL Dz_var            ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS

! Pointers used for finebound and restrict.  Notice that I declare "finevar" not as a pointer,
! but as an "elliptic" array.  This is because in order to interpolate fine grid boundaries
! we need all the associated arrays at previous time levels.

  REAL coarsevar         ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL finevar           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = ELLIPTIC, STORAGE = ALWAYS

! Pointers used for syncboxes.

  REAL box1var           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS
  REAL box2var           ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = POINTER, STORAGE = ALWAYS


! ****************************
! ***   AUXILIARY ARRAYS   ***
! ****************************

! These arrays are used for holding temporary information.

  REAL auxarray         ! SYMMETRYR = 0, SYMMETRYZ= 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC
  REAL Dr_auxarray      ! SYMMETRYR = 0, SYMMETRYZ= 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC
  REAL Dz_auxarray      ! SYMMETRYR = 0, SYMMETRYZ= 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC


! ***********************
! ***   COORDINATES   ***
! ***********************

! r coordinate (distance to axis): r = sqrt(x**2 + y**2)

  REAL r                 ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC

! z coordinate.

  REAL z                 ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC

! rr coordinate (distance to origin):  rr = sqrt(r**2 + z**2)

  REAL rr                ! SYMMETRYR = 0, SYMMETRYZ = 0, INTENT = AUXILIARY, STORAGE = ALWAYS, NOSYNC


! *******************
! ***   SLICING   ***
! *******************

! Lapse and derivatives.

  REAL alpha            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND

  REAL Dr_alpha         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_alpha         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Drr_alpha        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_alpha        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_alpha        ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_alpha        ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_alpha        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Time derivative of lapse (needed for some gauge conditions).

  REAL dtalpha          ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS

  REAL Dr_dtalpha       ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_dtalpha       ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_dtalpha      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_dtalpha      ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Second covariant derivative (both indexes down, divided by corresponding r power).

  REAL D2cov_alpha_A    ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2cov_alpha_B    ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2cov_alpha_H    ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL D2cov_alpha_C    ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL D2cov_alpha_C1   ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL D2cov_alpha_C2   ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL D2cov_alpha_lambda ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Laplacian.

  REAL Lapla_alpha      ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! d (d alpha/r) (for regularization).
!  r  r

  REAL DD_alphar        ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Bona-Masso gauge function f.

  REAL falpha           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! *****************
! ***   SHIFT   ***
! *****************

! Shift (index up) and derivatives.

  REAL beta_r		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(shift/="none"), NOBOUND
  REAL beta_z		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL(shift/="none"), NOBOUND
  REAL beta_p		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom.and.(shift/="none")), NOBOUND

  REAL Dr_beta_r	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_beta_r	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Drr_beta_r	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dzz_beta_r	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Drz_beta_r	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL Dr_beta_z	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_beta_z	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Drr_beta_z	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dzz_beta_z	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Drz_beta_z	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL Dr_beta_p	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL Dz_beta_p	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL Drr_beta_p	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL Dzz_beta_p	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL Drz_beta_p	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))

  REAL DAr_beta_r	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_beta_r	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAr_beta_z	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_beta_z	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAr_beta_p	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL DAz_beta_p	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))

! Time derivative of shift for various shift conditions (e.g. Gammadriver).

  REAL dtbeta_r	        ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(shift/="none")
  REAL dtbeta_z	        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL(shift/="none")
  REAL dtbeta_p	        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))

! Spatial derivatives of time derivative of the shift.

  REAL Dr_dtbeta_r	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_dtbeta_r	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dr_dtbeta_z	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_dtbeta_z	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dr_dtbeta_p	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL Dz_dtbeta_p	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))

  REAL DAr_dtbeta_r	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_dtbeta_r	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAr_dtbeta_z	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_dtbeta_z	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAr_dtbeta_p	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))
  REAL DAz_dtbeta_p	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom.and.(shift/="none"))

! Conformal divergence of shift and its derivative.

  REAL DIV_beta	        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dr_DIV_beta      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_DIV_beta      ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! d (beta_r/r) (for regularization).
!  r

  REAL DD_beta_rr	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Gammadriver function.

  REAL fdriver		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(shift/="none")

  REAL Dr_fdriver	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL Dz_fdriver	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_fdriver	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_fdriver	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")


! **************************
! ***   SPATIAL METRIC   ***
! **************************

! The spatial metric takes the following form:
!
!   2       4  /      2       2    2       2
! dl  =  psi   |  A dr  + B dz  + r  H dphi
!              \
!
!             /            2                        \ \
!	+ 2 r | C dr dz + r C dr dphi + r C dz dphi | |
!             \              1             2        / /

! Conformal factor and derivatives (remember that psi = exp(phi)).
! I also define an arrays psi2=psi**2 and psi4 = psi**4.

  REAL phi		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND

  REAL Dr_phi		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_phi          	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Drr_phi         	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_phi         	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_phi         	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_phi		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_phi		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL psi              ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL psi2             ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL psi4             ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Inverse square conformal factor: chi = 1/psi**2 = exp(-2*phi)

  REAL chi		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND

  REAL Dr_chi		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_chi          	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Drr_chi         	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_chi         	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_chi         	! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_chi		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_chi		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! d (d phi/r) (for regularization).
!  r  r

  REAL DD_phir         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Conformal spatial metric.

  REAL A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND
  REAL C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND

  REAL C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom), NOBOUND
  REAL C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom), NOBOUND

! Derivatives of A.

  REAL Dr_A		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_A		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drr_A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_A		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DAr_A		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_A		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Derivatives of B.

  REAL Dr_B		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_B		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drr_B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_B		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DAr_B		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_B		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Derivatives of H.

  REAL Dr_H		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_H		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drr_H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_H		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DAr_H		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_H		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Derivatives of C.

  REAL Dr_C		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_C		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drr_C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_C		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DAr_C		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_C		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Derivatives of C1 and C2.

  REAL Dr_C1		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_C1		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Drr_C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dzz_C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Drz_C1		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL DAr_C1		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)
  REAL DAz_C1		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)

  REAL Dr_C2		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_C2		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Drr_C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dzz_C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Drz_C2		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL DAr_C2		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)
  REAL DAz_C2		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)

! Physical spatial metric.

  REAL A_PHYS		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL B_PHYS		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL H_PHYS		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL C_PHYS		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL C1_PHYS		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL C2_PHYS		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Inverse conformal metric functions.
! The components of the conformal inverse metric
! are given in terms of the functions g_f as:
!
! gamma^rr  =  g_A
!
! gamma^zz  =  g_B
!
! gamma^pp  =  g_H/r**2
!
! gamma^rz  =  r g_C
!
! gamma^rp  =  r g_C1
!
! gamma^zp  =  g_C2

  REAL g_A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL g_B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL g_H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL g_C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL g_C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL g_C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Derivatives of inverse conformal metric.

  REAL Dr_g_A		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_g_A		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_g_B		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_g_B		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_g_H		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_g_H		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_g_C		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_g_C		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_g_C1		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_g_C1		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL Dr_g_C2		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_g_C2		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Determinant of conformal metric divided by r**2:
!
!                  2     2      2   2
! hdet =  A B H - r [ H C + A C2 + r C1 ( B C1 - 2 C C2 ) ]
!
! (Notice that hdet must remain static for langrangian evolutions).

  REAL hdet		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL ihdet		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT

  REAL Dr_hdet		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL Dz_hdet		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT


! **************************************
! ***   CONFORMAL SPHERICAL METRIC   ***
! **************************************

! Components of the conformal metric in spherical coordinates.
! Here the subindex t stands for the angle theta, and the
! subindex p for the angle phi.
!
! The coordinate transformation is (remember theta is
! mesured from the axis):
!
! r = rr sin(theta)
! z = rr cos(theta)
!
! Notice that phi is already one of our coordinates as we are
! using cylindrical coordinates (r,z,phi).

  REAL grr		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL gtt		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL gpp		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL grt		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL grp		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL gtp		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Determinant of conformal spherical metric.

  REAL hdetsph		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Inverse conformal spherical metric.

  REAL ginvrr		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL ginvtt		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL ginvpp		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL ginvrt		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL ginvrp		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL ginvtp		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS


! *******************************
! ***   EXTRINSIC CURVATURE   ***
! *******************************

! Trace of extrinsic curvature and derivatives.

  REAL trK              ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL Dr_trK           ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_trK           ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_trK          ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_trK          ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Traceless extrinsic curvature.

  REAL KTA		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL KTB		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL KTH		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL KTC		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = ALWAYS

  REAL KTC1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom)
  REAL KTC2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom)

! Derivatives.

  REAL Dr_KTA		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_KTA		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_KTB		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_KTB		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_KTH		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_KTH		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_KTC		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_KTC		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_KTC1		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_KTC1		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL Dr_KTC2		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_KTC2		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL DAr_KTA		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_KTA		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_KTB		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_KTB		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_KTH		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_KTH		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_KTC		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_KTC		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_KTC1		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)
  REAL DAz_KTC1		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)

  REAL DAr_KTC2		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)
  REAL DAz_KTC2		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)

! Contravariant extrinsic curvature components.

  REAL KT_up_rr		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT_up_zz		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT_up_pp		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT_up_rz		! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL KT_up_rp		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL KT_up_zp		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Divergence of the extrinsic curvature (index up).

  REAL DIV_KT_r         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DIV_KT_z         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DIV_KT_p         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Divergence minus KT*Delta (with 3 indices) as appears on Delta evolution equation.

  REAL DIVA_KT_r        ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DIVA_KT_z        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DIVA_KT_p        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Squared traceless extrinsic curvature.

  REAL KT2_A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT2_B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT2_H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KT2_C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL KT2_C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL KT2_C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL KT2_lambda       ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Scalar KT2 = KT_ij KT^ij.

  REAL KT2              ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Full extrinsic curvature.

  REAL KA		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KB		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KH		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL KC		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL KC1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL KC2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

! Square of extrinsic curvature:  K2 = K_ij K^ij

  REAL K2               ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! ***************************
! ***   DELTA VARIABLES   ***
! ***************************

! BSSN Delta variables (index up) and derivatives. The Deltas are defined as:
!
!      i           i      ^  i
! Delta  : =  Gamma  -  Gamma
!
! where Gamma^i is defined as:
!
!      i      mn      i
! Gamma  :=  g   Gamma
!                     mn
!
! with Gamma^i_mn the (conformal) Christoffel symbols,
! and where ^ refers to the flat space value.
! We finally find:
!
!      i           ij           ij              ^  i
! Delta  = - (- d g   -  (1/2) g  d ln hdet - Gamma   )
!                j                 j

  REAL Delta_r          ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL Delta_z          ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = ALWAYS
  REAL Delta_p          ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL(angmom)

  REAL Dr_Delta_r       ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_Delta_r       ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_Delta_z       ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_Delta_z       ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Dr_Delta_p       ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL Dz_Delta_p       ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL DAr_Delta_r      ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_Delta_r      ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_Delta_z      ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_Delta_z      ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

  REAL DAr_Delta_p      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)
  REAL DAz_Delta_p      ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL((shift/="none").and.angmom)

! Initial values of Deltas.  This is important for the shift conditions
! since in many cases Delta is non-trivial at t=0.

  REAL Delta0_r         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL Delta0_z         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS, CHECKPOINT
  REAL Delta0_p         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom), CHECKPOINT

! d ( Delta_r / r) (for regularization).
!  r

  REAL DD_Delta_rr      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Auxiliary: Deltas as originally defined.

  REAL DelDef_r         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DelDef_z         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL DelDef_p         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)


! ************************************
! ***   REGULARIZATION VARIABLES   ***
! ************************************

! lambda = (A - H)/r**2.

  REAL lambda           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS, NOBOUND

  REAL Dr_lambda        ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_lambda        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL Drr_lambda       ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dzz_lambda       ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Drz_lambda       ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_lambda       ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_lambda       ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! Alambda = (KTA - KTH)/r**2.

  REAL Alambda          ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS

  REAL Dr_Alambda       ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_Alambda       ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_Alambda      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_Alambda      ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")

! g_lambda := (g_A - g_H)/r**2 = (C**2 - B*lambda - C2**2)*ihdet.

  REAL g_lambda         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Auxiliary: lambda and Alambda as originally defined.

  REAL lamDef           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL AlamDef          ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXiLIARY, STORAGE = ALWAYS


! **************************
! ***   3-RICCI TENSOR   ***
! **************************

! Notice that this is the full physical Ricci tensor,
! and not the conformal Ricci.

! Components of Ricci tensor.

  REAL RIC_A		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL RIC_B		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL RIC_H		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL RIC_C		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL RIC_C1		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)
  REAL RIC_C2		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(angmom)

  REAL RIC_lambda	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Scalar curvature (trace of Ricci): RSCAL

  REAL RSCAL		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! **********************
! ***   Z4c ARRAYS   ***
! **********************

! Z4 theta constraint variable. Must vanish for physical solutions.
! They always have storage, but are set to zero and do not evolve
! for BSSN.

  REAL z4theta          ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = ALWAYS

  REAL Dr_z4theta       ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL Dz_z4theta       ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL DAr_z4theta      ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")
  REAL DAz_z4theta      ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(shift/="none")


! *********************************
! ***   CHARACTERISTIC SPEEDS   ***
! *********************************

! Speed of light.

  REAL vl_rp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL vl_rm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL vl_zp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL vl_zm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Slicing gauge speed.

  REAL va_rp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL va_rm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL va_zp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL va_zm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

! Shift gauge speed.

  REAL vs_rp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL vs_rm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS

  REAL vs_zp            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS
  REAL vs_zm            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = ALWAYS


! ***********************
! ***   WEYL TENSOR   ***
! ***********************

! The full Weyl tensor is decomposed into its
! three-dimensional electric and magnetic parts.

! Electric Weyl.

  REAL WEYL_E_A         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_E_B         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_E_H         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_E_C         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)

  REAL WEYL_E_C1        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_E_C2        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)

! Magnetic Weyl.

  REAL WEYL_B_A         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_B_B         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_B_H         ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_B_C         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)

  REAL WEYL_B_C1        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)
  REAL WEYL_B_C2        ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)


! ***********************
! ***   WEYL SCALARS  ***
! ***********************

  REAL WEYL_psi0        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL WEYL_psi1        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL WEYL_psi2        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL WEYL_psi3        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL WEYL_psi4        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv.or.wave_extract)


! ********************************
! ***   CURVATURE INVARIANTS   ***
! ********************************

  REAL curvI            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL curvJ            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)
  REAL curvS            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL(curvInv)


! ***********************
! ***   CONSTRAINTS   ***
! ***********************

! Hamiltonian constraint.

  REAL ham              ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! Momentum constraints.

  REAL mom_r            ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL mom_z            ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL mom_p            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL(angmom)

! CDelta

  REAL CDelta_r		! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL CDelta_z		! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL CDelta_p		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = CONDITIONAL(angmom)

! Clambda:    r**2*lambda - (A-B)

  REAL Clambda		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS

! CAlambda:   r**2*Alambda - (KTA-KTB)

  REAL CAlambda		! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *************************
! ***   STRESS-ENERGY   ***
! *************************

!                                          ab
! rho:       Energy density:  rho = n  n  T
!                                    a  b
!                                           i          i  ab
! J_i:       Momentum density (index up):  J  =  - n  P  T
!                                                   a  b
!                                                                       mn
! S_f:       Components of stress tensor (indices down):  S   = P   P  T
!                                                          ij    im  jn
!
! trS:       Trace of stress tensor
!
! In the above expressions n^a = (1/alpha,-beta^i/alpha) is
! the unit timelike normal to the spatial hypersurfaces, and
! P^a_b = delta^a_b + n^a n_b is the projection operator.
!
! Notice that the momentum density is defined wit index up, while
! the stress tensor is defined with both indices down.

  REAL	rho             ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

  REAL	J_r	 	! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL	J_z	 	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL	J_p	 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (angmom.and.(mattertype/="vacuum"))

  REAL	S_A	 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL	S_B	 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL	S_H	 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")
  REAL	S_C	 	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

  REAL	S_C1	 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (angmom.and.(mattertype/="vacuum"))
  REAL	S_C2	 	! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (angmom.and.(mattertype/="vacuum"))

  REAL	S_lambda 	! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")

  REAL	trS             ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (mattertype/="vacuum")


! ****************
! ***   MASS   ***
! ****************

! mass_sch:   Pseudo-Schwarzschild mass.
! mass_ADM:   ADM mass.

  REAL	mass_sch        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS
  REAL	mass_ADM        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = OUTPUT, STORAGE = ALWAYS


! *****************************
! ***   REAL SCALAR FIELD   ***
! *****************************

! Scalar field and derivatives.

  REAL scalar_phi	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0), NOBOUND

  REAL Dr_scalar_phi    !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dz_scalar_phi    !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)

  REAL Drr_scalar_phi   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dzz_scalar_phi   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Drz_scalar_phi   !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)

! Spatial derivatives: Xi_i = d phi/dx^i.

  REAL scalar_xi_r      !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0), NOBOUND
  REAL scalar_xi_z      !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0), NOBOUND

! Time derivative:  Pi = n^m d_m phi = (dphi/dt - beta^i dphi/dx^i) / alpha

  REAL scalar_pi       	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)

! Derivatives of Pi and Xi.

  REAL Dr_scalar_pi	!  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dz_scalar_pi	!  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)

  REAL Dr_scalar_xi_r	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dz_scalar_xi_r	!  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dr_scalar_xi_z	!  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL Dz_scalar_xi_z	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)

! Advective derivatives of Pi and Xi.

  REAL DAr_scalar_pi	!  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))
  REAL DAz_scalar_pi	!  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))

  REAL DAr_scalar_xi_r	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))
  REAL DAz_scalar_xi_r	!  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))
  REAL DAr_scalar_xi_z	!  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))
  REAL DAz_scalar_xi_z	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"scalar")/=0).and.(shift/="none"))

! Scalar field potential V and derivative VP = dV/dphi.

  REAL scalar_V 	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)
  REAL scalar_VP 	!  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"scalar")/=0)


! ********************************
! ***   COMPLEX SCALAR FIELD   ***
! ********************************

! For the complex scalar field we use two real fields
! for the real and imaginary parts, coupled only through
! the potential.

! Real and imaginary parts of scalar field and derivatives.

  REAL complex_phiR        !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND
  REAL complex_phiI        !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND

  REAL Dr_complex_phiR     !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_phiR     !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dr_complex_phiI     !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_phiI     !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

  REAL Drr_complex_phiR    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dzz_complex_phiR    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Drz_complex_phiR    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Drr_complex_phiI    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dzz_complex_phiI    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Drz_complex_phiI    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

! Spatial derivatives: Xi_i = d phi/dx^i.

  REAL complex_xiR_r       !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND
  REAL complex_xiR_z       !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND

  REAL complex_xiI_r       !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND
  REAL complex_xiI_z       !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0), NOBOUND

! Time derivative:  Pi = n^m d_m phi = (dphi/dt - beta dphi/dr) / alpha

  REAL complex_piR         !  SYMMETRYR = +1, SYMMETRYZ = +1,  INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL complex_piI         !  SYMMETRYR = +1, SYMMETRYZ = +1,  INTENT = EVOLVE, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

! Derivatives of Pi and Xi.

  REAL Dr_complex_piR      !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_piR      !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

  REAL Dr_complex_piI      !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_piI      !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

  REAL Dr_complex_xiR_r    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_xiR_r    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dr_complex_xiR_z    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_xiR_z    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

  REAL Dr_complex_xiI_r    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_xiI_r    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dr_complex_xiI_z    !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL Dz_complex_xiI_z    !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)

! Advective derivatives of Pi and Xi.

  REAL DAr_complex_piR     !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_piR     !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))

  REAL DAr_complex_piI     !  SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_piI     !  SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))

  REAL DAr_complex_xiR_r   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_xiR_r   !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAr_complex_xiR_z   !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_xiR_z   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))

  REAL DAr_complex_xiI_r   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_xiI_r   !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAr_complex_xiI_z   !  SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))
  REAL DAz_complex_xiI_z   !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL ((index(mattertype,"complex")/=0).and.(shift/="none"))

! Complex scalar field potential V and derivative VP.

  REAL complex_V           !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL complex_VPR         !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)
  REAL complex_VPI         !  SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (index(mattertype,"complex")/=0)


! **************************
! ***   MAXWELL FIELDS   ***
! **************************


! ***********************
! ***   BRILL WAVES   ***
! ***********************

! Brill wave q function.

  REAL brillq           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (idata=="BrillWave")


! ***************************
! ***   ELLIPTIC SOLVER   ***
! ***************************

! For the moment the ellpitic solver solves
! a Poisson equation of the form:
!
!     __2                   5
!     \/  u  +  S1 u  + S5 u  =  S0
!
! Here S0 is a source term, S1 is the coefficient
! of the linear term, and S5 the coefficient
! of the term that multiplies u^5 (this term
! typically appears in the Hamiltonian constraint).

  REAL ell_S0           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")
  REAL ell_S1           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")
  REAL ell_S5           ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")

! The solution of elliptic solver is called 'ell_u'.
! We also add storage for its derivatives.

  REAL ell_u            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = ELLIPTIC, STORAGE = CONDITIONAL (ELL_solver/="none"), NOBOUND

  REAL Dr_ell_u         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")
  REAL Dz_ell_u         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")

  REAL Drr_ell_u        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")
  REAL Dzz_ell_u        ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")
  REAL Drz_ell_u        ! SYMMETRYR = -1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver/="none")

! For the WaveElliptic solver we define v=du/dt, with "t" a fake time for the internal evolution.

  REAL ell_v            ! SYMMETRYR = +1, SYMMETRYZ = +1, INTENT = ELLIPTIC, STORAGE = CONDITIONAL (ELL_solver=="wave")

  REAL Dr_ell_v         ! SYMMETRYR = -1, SYMMETRYZ = +1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver=="wave")
  REAL Dz_ell_v         ! SYMMETRYR = +1, SYMMETRYZ = -1, INTENT = AUXILIARY, STORAGE = CONDITIONAL (ELL_solver=="wave")